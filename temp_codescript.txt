// fly.toml:

app = "townwall"
primary_region = "otp"

[mounts]
  source = "postgres"
  destination = "/postgres-volume"

[env]
  PORT = "8080"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true

----------------------------------------

// Dockerfile:

FROM node:lts-alpine AS builder
# Install necessary tools
RUN apk add --no-cache libc6-compat yq --repository=https://dl-cdn.alpinelinux.org/alpine/edge/community
# Install pnpm
RUN corepack enable && corepack prepare pnpm@latest --activate
WORKDIR /app
# Copy the content of the project to the machine
COPY . .
RUN yq --inplace --output-format=json '(.devDependencies = (.devDependencies | to_entries | map(select(.key | test("^(@jest/globals|@playwright/test|@ts-safeql/eslint-plugin|jest|jest-environment-jsdom|libpg-query|prettier|prettier-plugin-embed|prettier-plugin-sql|stylelint|stylelint-config-upleveled)$") | not)) | from_entries))' package.json
RUN pnpm install
RUN pnpm build

# Multi-stage builds: runner stage
FROM node:lts-alpine AS runner
ENV NODE_ENV production
# Install necessary tools
RUN apk add bash postgresql
RUN corepack enable && corepack prepare pnpm@latest --activate
WORKDIR /app

# Copy built app
COPY --from=builder /app/.next ./.next

# Copy only necessary files to run the app (minimize production app size, improve performance)
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/migrations ./migrations
COPY --from=builder /app/public ./public
COPY --from=builder /app/package.json ./
COPY --from=builder /app/next.config.js ./

# Copy scripts and make them executable
COPY --from=builder /app/scripts ./scripts
RUN chmod +x /app/scripts/fly-io-start.sh
RUN chmod +x /app/scripts/alpine-postgresql-setup-and-start.sh

CMD ["./scripts/fly-io-start.sh"]

----------------------------------------

// .dockerignore:

# Secrets
*.env
.env.test
.env*.local
.env.development

# Scripts
*.sql

# Documentation
README.md

# Next.js build artifacts
build
.vercel
.next

# Tests
playwright
playwright.config.ts
coverage
*/__tests__
jest.config.js

# Dependencies
node_modules

# Git and GitHub
.git
.github

# Linting, formatting config
.eslintcache
.eslintignore
.eslintrc
prettier.config.cjs

# Docker
Dockerfile
.dockerignore

# TypeScript cache
.tsbuildinfo

----------------------------------------

// scripts/alpine-postgresql-setup-and-start.sh:

#!/usr/bin/env bash

# Exit if any command exits with a non-zero exit code
set -o errexit

echo "Setting up PostgreSQL on Alpine Linux..."

export PGHOST=/postgres-volume/run/postgresql
export PGDATA="$PGHOST/data"

echo "Adding exclusive data directory permissions for postgres user..."
chmod 0700 "$PGDATA"

echo "Initializing database cluster..."
initdb -D "$PGDATA"

echo "Prepending volume path to Unix Domain Socket path..."
sed -i "s/#unix_socket_directories = '\/run\/postgresql'/unix_socket_directories = '\/postgres-volume\/run\/postgresql'/g" "$PGDATA/postgresql.conf"

echo "Enabling connections on all available IP interfaces..."
echo "listen_addresses='*'" >> "$PGDATA/postgresql.conf"

echo "Starting PostgreSQL..."
pg_ctl start -D "$PGDATA"

echo "Creating database, user and schema..."
psql -U postgres postgres << SQL
  CREATE DATABASE $PGDATABASE;
  CREATE USER $PGUSERNAME WITH ENCRYPTED PASSWORD '$PGPASSWORD';
  GRANT ALL PRIVILEGES ON DATABASE $PGDATABASE TO $PGUSERNAME;
  \\connect $PGDATABASE
  CREATE SCHEMA $PGUSERNAME AUTHORIZATION $PGUSERNAME;
SQL

----------------------------------------

// scripts/fly-io-start.sh:

#!/usr/bin/env bash

# Exit if any command exits with a non-zero exit code
set -o errexit

if [[ ! -f /postgres-volume/run/postgresql/data/postgresql.conf ]]; then
  echo "❗️ No PostgreSQL database found, run the setup script"
  sleep infinity
fi

echo "Setting up PostgreSQL on Fly.io..."
su postgres -c "pg_ctl start -D /postgres-volume/run/postgresql/data"

pnpm migrate up
./node_modules/.bin/next start

----------------------------------------

// next.config.js:

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
};
export default nextConfig;

----------------------------------------

// util/config.js:

import postgres from 'postgres';
import { config } from 'dotenv-safe';

export const postgresConfig = {
  ssl: Boolean(process.env.POSTGRES_URL),
  transform: {
    ...postgres.camel,
    undefined: null,
  },
};

export function setEnvironmentVariables() {
  if (process.env.NODE_ENV === 'production' || process.env.CI) {
    if (process.env.POSTGRES_URL) {
      process.env.PGHOST = process.env.POSTGRES_HOST;
      process.env.PGDATABASE = process.env.POSTGRES_DATABASE;
      process.env.PGUSERNAME = process.env.POSTGRES_USER;
      process.env.PGPASSWORD = process.env.POSTGRES_PASSWORD;
    }
    return;
  }
  config();
}

----------------------------------------

// util/geocode.ts:

export async function getLocationName(latitude: number, longitude: number) {
  const apiKey = process.env.NEXT_PUBLIC_OPENCAGE_API_KEY;
  if (!apiKey) {
    throw new Error('API key for OpenCage is not defined');
  }

  const url = `https://api.opencagedata.com/geocode/v1/json?q=${latitude}+${longitude}&key=${apiKey}`;

  try {
    const response = await fetch(url);
    const data = await response.json();

    if (data.results && data.results.length > 0) {
      const result = data.results[0];
      const city =
        result.components.city ||
        result.components.town ||
        result.components.village ||
        '';
      const country = result.components.country || '';
      return { city, country };
    } else {
      throw new Error('No results found');
    }
  } catch (error) {
    console.error('Error fetching location:', error);
    return { city: '', country: '' };
  }
}

export async function getCityAndCountry(
  latitude: number,
  longitude: number,
): Promise<{ city: string; country: string }> {
  const response = await fetch(
    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`,
  );
  if (!response.ok) {
    throw new Error('Failed to fetch location data');
  }

  const data = await response.json();
  const city =
    data.address.city || data.address.town || data.address.village || 'Unknown';
  const country = data.address.country || 'Unknown';
  return { city, country };
}

----------------------------------------

// ley.config.js:

import { postgresConfig, setEnvironmentVariables } from './util/config.js';

setEnvironmentVariables();

export default postgresConfig;

----------------------------------------

