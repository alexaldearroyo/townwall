// src/app/(auth)/api/categories/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import {
  createCategory,
  getCategories,
  removePostCategory,
} from '../../../../../database/categories';

export async function GET(): Promise<NextResponse> {
  try {
    const categories = await getCategories();
    return NextResponse.json(categories);
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const { categoryName, description } = await request.json();
    const category = await createCategory(categoryName, description);
    return NextResponse.json({ category });
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    const { categoryName, postId } = await request.json();
    await removePostCategory(postId, categoryName);
    const categories = await getCategories();
    return NextResponse.json(categories);
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/(auth)/api/delete/route.ts:

// src/app/(auth)/api/delete/route.ts

import { NextResponse } from 'next/server';
import { getUserById, deleteUserById } from '../../../../../database/users';
import {
  getSessionByToken,
  deleteSessionByToken,
} from '../../../../../database/sessions';

export async function POST(request: Request) {
  const cookieHeader = request.headers.get('cookie');
  const cookies = new Map(
    cookieHeader?.split(';').map((cookie) => {
      const [name, ...valueParts] = cookie.trim().split('=');
      return [name, valueParts.join('=')];
    }),
  );

  const sessionToken = cookies.get('session');

  if (!sessionToken) {
    return NextResponse.json(
      { errors: [{ message: 'No session token found' }] },
      { status: 400 },
    );
  }

  const session = await getSessionByToken(sessionToken);

  if (!session) {
    return NextResponse.json(
      { errors: [{ message: 'Invalid session token' }] },
      { status: 401 },
    );
  }

  const user = await getUserById(session.userId);

  if (!user) {
    return NextResponse.json(
      { errors: [{ message: 'User not found' }] },
      { status: 404 },
    );
  }

  await deleteUserById(user.id);
  await deleteSessionByToken(sessionToken);

  const response = NextResponse.json({ message: 'User deleted successfully' });
  response.headers.set('Set-Cookie', 'session=; Max-Age=0; Path=/');

  return response;
}

----------------------------------------

// src/app/(auth)/api/followers/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getSessionByToken } from '../../../../../database/sessions';
import { getFollowers } from '../../../../../database/follows';

export async function GET(request: NextRequest) {
  const sessionToken = request.cookies.get('session')?.value;

  if (!sessionToken) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 },
    );
  }

  const session = await getSessionByToken(sessionToken);
  if (!session) {
    return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
  }

  const followers = await getFollowers(session.userId);

  return NextResponse.json(followers);
}

----------------------------------------

// src/app/(auth)/api/following/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getSessionByToken } from '../../../../../database/sessions';
import { getFollowingUsers } from '../../../../../database/follows';

export async function GET(request: NextRequest) {
  const sessionToken = request.cookies.get('session')?.value;

  if (!sessionToken) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 },
    );
  }

  const session = await getSessionByToken(sessionToken);
  if (!session) {
    return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
  }

  const followingUsers = await getFollowingUsers(session.userId);

  return NextResponse.json(followingUsers);
}

----------------------------------------

// src/app/(auth)/api/follows/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getSessionByToken } from '../../../../../database/sessions';
import { followUser, unfollowUser } from '../../../../../database/follows';
import { sql } from '../../../../../database/connect';

export async function POST(request: NextRequest) {
  const { followerId, followedId } = await request.json();
  const sessionToken = request.cookies.get('session')?.value;

  if (!sessionToken) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 },
    );
  }

  const session = await getSessionByToken(sessionToken);
  if (!session || session.userId !== followerId) {
    return NextResponse.json(
      { error: 'Invalid session or follower ID' },
      { status: 401 },
    );
  }

  await followUser(followerId, followedId);
  return NextResponse.json(
    { message: 'Followed successfully' },
    { status: 200 },
  );
}

export async function DELETE(request: NextRequest) {
  const { followerId, followedId } = await request.json();
  const sessionToken = request.cookies.get('session')?.value;

  if (!sessionToken) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 },
    );
  }

  const session = await getSessionByToken(sessionToken);
  if (!session || session.userId !== followerId) {
    return NextResponse.json(
      { error: 'Invalid session or follower ID' },
      { status: 401 },
    );
  }

  await unfollowUser(followerId, followedId);
  return NextResponse.json(
    { message: 'Unfollowed successfully' },
    { status: 200 },
  );
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const followerId = parseInt(url.searchParams.get('followerId') || '0', 10);
  const followedId = parseInt(url.searchParams.get('followedId') || '0', 10);

  if (!followerId || !followedId) {
    return NextResponse.json(
      { error: 'Follower ID and Followed ID are required' },
      { status: 400 },
    );
  }

  const [result] = await sql<{ '?column?': number }[]>`
    SELECT
      1
    FROM
      follows
    WHERE
      follower_id = ${followerId}
      AND followed_id = ${followedId}
    LIMIT
      1
  `;

  const isFollowing = result !== undefined;
  return NextResponse.json({ isFollowing }, { status: 200 });
}

----------------------------------------

// src/app/(auth)/api/interests/route.ts:

import { NextResponse } from 'next/server';
import {
  createCategory,
  getCategoryByName,
  addUserCategory,
  getUserCategories,
  removeUserCategory,
} from '../../../../../database/categories';
import { getSessionByToken } from '../../../../../database/sessions';
import { NextRequest } from 'next/server';

function toTitleCase(str: string): string {
  return str.replace(/\w\S*/g, (txt) => {
    return txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
  });
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { categoryName } = body;

    const sessionToken = request.cookies.get('session');
    if (!sessionToken) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const session = await getSessionByToken(sessionToken.value);
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.userId;
    const titleCaseCategoryName = toTitleCase(categoryName);
    let category = await getCategoryByName(titleCaseCategoryName);

    if (!category) {
      category = await createCategory(titleCaseCategoryName);
    }

    await addUserCategory(userId, category.id);

    const userCategories = await getUserCategories(userId);
    return NextResponse.json({ categories: userCategories });
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 },
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const body = await request.json();
    const { categoryName, userId } = body;

    const sessionToken = request.cookies.get('session');
    if (!sessionToken) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const session = await getSessionByToken(sessionToken.value);
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const titleCaseCategoryName = toTitleCase(categoryName);
    await removeUserCategory(userId, titleCaseCategoryName);

    const userCategories = await getUserCategories(userId);
    return NextResponse.json({ categories: userCategories });
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/(auth)/api/login/route.ts:

import { NextResponse } from 'next/server';
import { getUserByUsernameOrEmail } from '../../../../../database/users'; // Cambiado
import { createSession } from '../../../../../database/sessions';
import bcrypt from 'bcrypt';
import { z } from 'zod';
import type { User } from '../../../../../database/users';

type LoginResponseBodyPost = { user: User } | { errors: { message: string }[] };

const loginSchema = z.object({
  identifier: z.string().min(3),
  password: z.string().min(3),
});

export async function POST(
  request: Request,
): Promise<NextResponse<LoginResponseBodyPost>> {
  try {
    const body = await request.json();
    console.log('Received login request:', body);

    const result = loginSchema.safeParse(body);

    if (!result.success) {
      console.log('Validation failed:', result.error.issues);
      return NextResponse.json(
        { errors: result.error.issues },
        { status: 400 },
      );
    }

    const user = await getUserByUsernameOrEmail(result.data.identifier); // Cambiado

    if (!user) {
      console.log('User not found:', result.data.identifier);
      return NextResponse.json(
        { errors: [{ message: 'Invalid username or password' }] },
        { status: 401 },
      );
    }

    // Add a log to verify the result of bcrypt.compare
    const passwordMatch = await bcrypt.compare(
      result.data.password,
      user.passwordHash,
    );
    console.log('Password match result:', passwordMatch);

    if (!passwordMatch) {
      console.log('Password mismatch for user:', result.data.identifier);
      return NextResponse.json(
        { errors: [{ message: 'Invalid username or password' }] },
        { status: 401 },
      );
    }

    const session = await createSession(user.id);

    console.log('Session created:', session);

    const response = NextResponse.json(
      { user: { ...user, slug: user.slug } },
      { status: 200 },
    );
    response.cookies.set('session', session.token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 60 * 60 * 12, // 12 hours
    });

    return response;
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json(
      { errors: [{ message: 'Internal server error' }] },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/(auth)/api/logout/route.ts:

// src/app/(auth)/api/logout/route.ts
import { deleteSessionByToken } from '../../../../../database/sessions';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest): Promise<NextResponse> {
  const sessionToken = request.cookies.get('session')?.value;

  if (!sessionToken) {
    return NextResponse.json(
      { errors: [{ message: 'No session token found' }] },
      { status: 400 },
    );
  }

  await deleteSessionByToken(sessionToken);

  const response = NextResponse.json({ message: 'Logged out successfully' });
  response.cookies.set('session', '', { maxAge: -1 });

  return response;
}

----------------------------------------

// src/app/(auth)/api/posts/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getSessionByToken } from '../../../../../database/sessions';
import { createPost, getPostsByUserId } from '../../../../../database/posts';
import {
  addPostCategory,
  getPostCategories,
  PostCategory,
} from '../../../../../database/posts_categories';

// Crear Post
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const sessionToken = request.cookies.get('session')?.value;
    if (!sessionToken) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 },
      );
    }

    const session = await getSessionByToken(sessionToken);
    if (!session) {
      return NextResponse.json({ error: 'Session not valid' }, { status: 401 });
    }

    const { title, content, slug, icon, categoryNames } = await request.json();

    if (!title || !content || !slug) {
      return NextResponse.json(
        { error: 'Title, content, and slug are required' },
        { status: 400 },
      );
    }

    // Verifica que categoryNames esté definido y sea un array
    const categoriesArray = Array.isArray(categoryNames) ? categoryNames : [];

    // Crear el post
    const post = await createPost(session.userId, title, content, slug, icon);

    // Construir URL completa para la API de categorías
    const baseUrl = new URL(request.url).origin;

    // Crear nuevas categorías y asociarlas al post
    const newCategoryResponses = await Promise.all(
      categoriesArray.map(async (categoryName) => {
        const response = await fetch(`${baseUrl}/api/categories`, {
          method: 'POST',
          body: JSON.stringify({ categoryName, description: '' }),
          headers: {
            'Content-Type': 'application/json',
          },
        });
        const jsonResponse = await response.json();
        if (!jsonResponse.category || !jsonResponse.category.id) {
          console.error('Invalid category response:', jsonResponse);
          throw new Error('Invalid category response');
        }

        // Asignar categoría al post
        await addPostCategory(post.id, jsonResponse.category.id);

        return jsonResponse.category.id;
      }),
    );

    return NextResponse.json(
      { ...post, userId: session.userId, categoryIds: newCategoryResponses },
      { status: 201 },
    );
  } catch (error) {
    console.error('Error creating post:', error);
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

// Obtener Posts por Usuario
export async function GET(request: NextRequest): Promise<NextResponse> {
  const url = new URL(request.url);
  const userId = url.searchParams.get('userId');

  if (!userId) {
    return NextResponse.json({ error: 'User ID is required' }, { status: 400 });
  }

  try {
    const posts = await getPostsByUserId(parseInt(userId, 10));

    const postsWithCategories = await Promise.all(
      posts.map(async (post) => {
        const categories = await getPostCategories(post.id);
        return { ...post, categories };
      }),
    );

    return NextResponse.json(postsWithCategories);
  } catch (error) {
    console.error('Error fetching posts:', error);
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/(auth)/api/profile/route.ts:

import { NextResponse } from 'next/server';
import {
  getUserById,
  updateUserProfile,
  UserProfile,
} from '../../../../../database/users';
import { getSessionByToken } from '../../../../../database/sessions';
import { z } from 'zod';
import { NextRequest } from 'next/server';

const profileSchema = z.object({
  fullName: z.string().optional(),
  description: z.string().optional(),
  interests: z.string().optional(),
  profileLinks: z.string().optional(),
  userImage: z.string().optional(),
  // location: z.string().optional(),
  birthdate: z.string().optional(),
  profession: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const result = profileSchema.safeParse(body);

    if (!result.success) {
      return NextResponse.json(
        { errors: result.error.issues },
        { status: 400 },
      );
    }

    const sessionCookie = request.cookies.get('session');
    const sessionToken = sessionCookie ? sessionCookie.value : null;

    if (!sessionToken) {
      return NextResponse.json(
        { errors: [{ message: 'Not authenticated' }] },
        { status: 401 },
      );
    }

    const session = await getSessionByToken(sessionToken);
    if (!session) {
      return NextResponse.json(
        { errors: [{ message: 'Invalid session token' }] },
        { status: 401 },
      );
    }

    const interestsArray = result.data.interests
      ? JSON.parse(result.data.interests)
      : [];
    const updatedUser = await updateUserProfile(session.userId, {
      ...result.data,
      interests: interestsArray,
    } as Partial<UserProfile>);

    return NextResponse.json({ user: updatedUser });
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { errors: [{ message: 'Internal server error' }] },
      { status: 500 },
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const sessionCookie = request.cookies.get('session');
    const sessionToken = sessionCookie ? sessionCookie.value : null;

    if (!sessionToken) {
      return NextResponse.json(
        { errors: [{ message: 'Not authenticated' }] },
        { status: 401 },
      );
    }

    const session = await getSessionByToken(sessionToken);
    if (!session) {
      return NextResponse.json(
        { errors: [{ message: 'Invalid session token' }] },
        { status: 401 },
      );
    }

    const user = await getUserById(session.userId);
    if (!user) {
      return NextResponse.json(
        { errors: [{ message: 'User not found' }] },
        { status: 404 },
      );
    }

    console.log(user);

    return NextResponse.json({ user });
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { errors: [{ message: 'Internal server error' }] },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/(auth)/api/register/route.ts:

import { NextResponse } from 'next/server';
import {
  createUser,
  getUserByUsername,
  getUserByEmail,
} from '../../../../../database/users';
import { createSession } from '../../../../../database/sessions';
import { z } from 'zod';
import type { User } from '../../../../../database/users';

type RegisterResponseBodyPost =
  | { user: User }
  | { errors: { message: string }[] };

const userSchema = z.object({
  username: z.string().min(3),
  password: z.string().min(3),
  email: z.string().email(),
  latitude: z.number(),
  longitude: z.number(),
});

export async function POST(
  request: Request,
): Promise<NextResponse<RegisterResponseBodyPost>> {
  try {
    const body = await request.json();
    const result = userSchema.safeParse(body);

    if (!result.success) {
      return NextResponse.json(
        {
          errors: result.error.issues.map((issue) => ({
            message: issue.message,
          })),
        },
        { status: 400 },
      );
    }

    const { username, password, email, latitude, longitude } = result.data;

    const existingUser = await getUserByUsername(username);
    const existingEmailUser = await getUserByEmail(email);

    if (existingUser) {
      return NextResponse.json(
        { errors: [{ message: 'Username already taken' }] },
        { status: 409 },
      );
    }
    if (existingEmailUser) {
      return NextResponse.json(
        { errors: [{ message: 'Email already in use' }] },
        { status: 409 },
      );
    }

    const profileId = Math.floor(Math.random() * 1000); // Generate a profile ID
    const slug = username.toLowerCase().replace(/\s+/g, '-') + '-' + Date.now(); // Generate a slug

    const user = await createUser(username, password, email, profileId, slug, {
      x: longitude,
      y: latitude,
    });

    // Create a session for the new user
    const session = await createSession(user.id);

    const response = NextResponse.json({ user }, { status: 201 });
    response.cookies.set('session', session.token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 60 * 60 * 12, // 12 hours
    });

    return response;
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { errors: [{ message: 'Internal server error' }] },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/(auth)/api/search/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { sql } from '../../../../../database/connect';
import { parseLocation, User } from '../../../../../database/users';
import { getCityAndCountry } from '../../../../../util/geocode';

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const query = url.searchParams.get('query');

  if (!query) {
    return NextResponse.json({ error: 'Query is required' }, { status: 400 });
  }

  const searchResults = await sql<
    {
      id: number;
      username: string;
      email: string;
      userImage: string;
      location: unknown | null;
    }[]
  >`
    SELECT
      id,
      username,
      email,
      user_image AS "userImage",
      st_astext (location) AS location
    FROM
      users
    WHERE
      username ILIKE ${'%' + query + '%'}
      OR location ILIKE ${'%' + query + '%'}
  `;

  const users = await Promise.all(
    searchResults.map(async (user) => {
      if (user.location) {
        const location = parseLocation(user.location as string);
        if (location) {
          const { city, country } = await getCityAndCountry(
            location.y,
            location.x,
          );
          user.location = `${city}, ${country}`;
        } else {
          user.location = 'Unknown';
        }
      }
      return user;
    }),
  );

  return NextResponse.json(users);
}

----------------------------------------

// src/app/api/comments/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getSessionByToken } from '../../../../database/sessions';
import {
  createPostComment,
  getCommentsByPostId,
} from '../../../../database/posts_comments'; // Cambiado

export async function POST(request: NextRequest) {
  const sessionToken = request.cookies.get('session')?.value;

  if (!sessionToken) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 },
    );
  }

  const session = await getSessionByToken(sessionToken);
  if (!session) {
    return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
  }

  const { postId, content } = await request.json();

  if (!postId || !content) {
    return NextResponse.json(
      { error: 'Post ID and content are required' },
      { status: 400 },
    );
  }

  const comment = await createPostComment(postId, session.userId, content); // Cambiado
  return NextResponse.json(comment, { status: 201 });
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const postId = url.searchParams.get('postId');

  if (!postId) {
    return NextResponse.json({ error: 'Post ID is required' }, { status: 400 });
  }

  const comments = await getCommentsByPostId(parseInt(postId, 10)); // Cambiado
  return NextResponse.json(comments);
}

----------------------------------------

// src/app/api/friends/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import {
  getFollowersWithLocation,
  getFollowingWithLocation,
} from '../../../../database/follows';

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const userId = url.searchParams.get('userId');

  if (!userId) {
    return NextResponse.json({ error: 'Invalid user ID' }, { status: 400 });
  }

  try {
    const followers = await getFollowersWithLocation(Number(userId));
    const following = await getFollowingWithLocation(Number(userId));
    const allFriends = [...followers, ...following].map((friend) => ({
      ...friend,
      location: friend.location as string,
    }));
    return NextResponse.json(allFriends);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch friends' },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/api/posts/user/[id]/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getPostsByUserId } from '../../../../../../database/posts';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } },
) {
  const userId = parseInt(params.id, 10);
  if (isNaN(userId)) {
    return NextResponse.json({ error: 'Invalid user ID' }, { status: 400 });
  }

  try {
    const posts = await getPostsByUserId(userId);
    return NextResponse.json(posts);
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/api/profile/[username]/comments/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getSessionByToken } from '../../../../../../database/sessions';
import {
  createProfileComment,
  getCommentsByProfileUserId,
} from '../../../../../../database/profiles_comments';
import { getUserByUsername } from '../../../../../../database/users';

export async function POST(request: NextRequest) {
  try {
    const sessionToken = request.cookies.get('session')?.value;

    if (!sessionToken) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 },
      );
    }

    const session = await getSessionByToken(sessionToken);
    if (!session) {
      return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
    }

    const { content } = await request.json();
    const username = request.nextUrl.pathname.split('/')[3];

    if (!username || !content) {
      return NextResponse.json(
        { error: 'Username and content are required' },
        { status: 400 },
      );
    }

    const user = await getUserByUsername(username);
    if (!user) {
      return NextResponse.json(
        { error: `User with username ${username} not found` },
        { status: 404 },
      );
    }

    const comment = await createProfileComment(
      user.id,
      session.userId,
      content,
    );

    return NextResponse.json(comment, { status: 201 });
  } catch (error) {
    console.error('Error adding comment:', error);
    return NextResponse.json(
      { error: `Failed to add comment: ${(error as Error).message}` },
      { status: 500 },
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const username = request.nextUrl.pathname.split('/')[3];

    if (!username) {
      return NextResponse.json(
        { error: 'Username is required' },
        { status: 400 },
      );
    }

    const user = await getUserByUsername(username);
    if (!user) {
      return NextResponse.json(
        { error: `User with username ${username} not found` },
        { status: 404 },
      );
    }

    const comments = await getCommentsByProfileUserId(user.id);
    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching comments:', error);
    return NextResponse.json(
      { error: `Failed to fetch comments: ${(error as any).message}` },
      { status: 500 },
    );
  }
}

----------------------------------------

// src/app/api/search/nearby/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { sql } from '../../../../../database/connect';

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const latitude = parseFloat(url.searchParams.get('latitude') || '0');
  const longitude = parseFloat(url.searchParams.get('longitude') || '0');
  const radius = parseInt(url.searchParams.get('radius') || '10'); // Radius in kilometers

  if (!latitude || !longitude) {
    return NextResponse.json(
      { error: 'Latitude and Longitude are required' },
      { status: 400 },
    );
  }

  const users = await sql<
    {
      id: number;
      username: string;
      email: string;
      userImage: string;
      location: unknown | null;
    }[]
  >`
    SELECT
      id,
      username,
      email,
      user_image AS "userImage",
      st_astext (location) AS location
    FROM
      users
    WHERE
      st_dwithin (
        location,
        st_setsrid (
          st_makepoint (
            ${longitude},
            ${latitude}
          ),
          4326
        ),
        ${radius} * 1000
      )
  `;

  return NextResponse.json(users);
}

----------------------------------------

// src/app/api/upload/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function POST(request: NextRequest) {
  try {
    const { image } = await request.json();

    if (!image) {
      return NextResponse.json({ error: 'No image provided' }, { status: 400 });
    }

    const uploadResponse = await cloudinary.uploader.upload(image, {
      folder: 'profile_pictures',
    });

    return NextResponse.json({ url: uploadResponse.secure_url });
  } catch (error) {
    console.error(error);
    return NextResponse.json({ error: 'Image upload failed' }, { status: 500 });
  }
}

----------------------------------------

// src/app/api/users/username/[username]/route.ts:

import { NextRequest, NextResponse } from 'next/server';
import { getUserByUsername } from '../../../../../../database/users';

export async function GET(
  request: NextRequest,
  { params }: { params: { username: string } },
) {
  const { username } = params;

  try {
    const user = await getUserByUsername(username);
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }
    return NextResponse.json(user);
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 },
    );
  }
}

----------------------------------------

